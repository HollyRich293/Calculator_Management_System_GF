import os
import qrcode
from PIL import Image
import sqlite3
import tkinter as tk
from tkinter import messagebox, ttk
import atexit

# Ensure paths
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))  # Script directory
DB_FILE = os.path.join(SCRIPT_DIR, "calculator_management.db")  # Database file
BARCODE_DIR = os.path.join(SCRIPT_DIR, "barcodes")  # Barcode directory
os.makedirs(BARCODE_DIR, exist_ok=True)  # Create barcode directory if it doesn't exist

# Database setup
conn = sqlite3.connect(DB_FILE)
cursor = conn.cursor()

# Create table for calculator assignments
cursor.execute("""
CREATE TABLE IF NOT EXISTS assignments (
    calculator_id TEXT PRIMARY KEY,
    student_name TEXT
)
""")
conn.commit()

# Ensure database connection closes on exit
@atexit.register
def close_db_connection():
    conn.close()

# Function to generate a barcode for a calculator
def generate_barcode(calculator_id):
    barcode_data = f"CALC-{calculator_id}"
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    qr.add_data(barcode_data)
    qr.make(fit=True)

    img = qr.make_image(fill_color="black", back_color="white")
    img_path = os.path.join(BARCODE_DIR, f"barcode_CALC-{calculator_id}.png")
    img.save(img_path)
    return img_path

# Function to borrow a calculator
def borrow_calculator(calculator_id, student_name):
    try:
        cursor.execute(
            "SELECT student_name FROM assignments WHERE calculator_id = ?",
            (calculator_id,)
        )
        result = cursor.fetchone()

        if result:  # Calculator is currently borrowed
            messagebox.showerror("Error", f"Calculator {calculator_id} is currently borrowed by {result[0]}.")
        else:  # Calculator is available
            cursor.execute(
                "INSERT INTO assignments (calculator_id, student_name) VALUES (?, ?)",
                (calculator_id, student_name)
            )
            conn.commit()
            messagebox.showinfo("Borrowed", f"Calculator {calculator_id} has been borrowed by {student_name}.")
    except sqlite3.Error as e:
        messagebox.showerror("Database Error", str(e))

# Function to return a calculator
def return_calculator(calculator_id):
    try:
        cursor.execute(
            "SELECT student_name FROM assignments WHERE calculator_id = ?",
            (calculator_id,)
        )
        result = cursor.fetchone()

        if result:  # Calculator is currently borrowed
            cursor.execute(
                "DELETE FROM assignments WHERE calculator_id = ?",
                (calculator_id,)
            )
            conn.commit()
            messagebox.showinfo("Returned", f"Calculator {calculator_id} was borrowed by {result[0]} and has been returned.")
        else:  # Calculator is not borrowed
            messagebox.showerror("Error", f"Calculator {calculator_id} is not currently borrowed.")
    except sqlite3.Error as e:
        messagebox.showerror("Database Error", str(e))

# Function to view calculator inventory
def view_inventory():
    inventory_window = tk.Toplevel()
    inventory_window.title("Calculator Inventory")

    tree = ttk.Treeview(inventory_window, columns=("ID", "Student"), show="headings")
    tree.heading("ID", text="Calculator ID")
    tree.heading("Student", text="Student Name")
    tree.pack(fill=tk.BOTH, expand=True)

    try:
        cursor.execute("SELECT * FROM assignments")
        for row in cursor.fetchall():
            tree.insert("", tk.END, values=row)
    except sqlite3.Error as e:
        messagebox.showerror("Database Error", str(e))

# Function to clear assignments at the end of the day
def clear_end_of_day():
    try:
        cursor.execute("DELETE FROM assignments")
        conn.commit()
        messagebox.showinfo("End of Day", "All assignments have been cleared.")
    except sqlite3.Error as e:
        messagebox.showerror("Database Error", str(e))

# GUI Application
def main_app():
    def on_borrow():
        calculator_id = calculator_dropdown.get()
        student_name = student_name_entry.get().strip()
        if calculator_id and student_name:
            borrow_calculator(calculator_id, student_name)
        else:
            messagebox.showerror("Error", "Please select a calculator and enter a student name.")

    def on_return():
        calculator_id = calculator_dropdown.get()
        if calculator_id:
            return_calculator(calculator_id)
        else:
            messagebox.showerror("Error", "Please select a calculator to return.")

    app = tk.Tk()
    app.title("Calculator Management System")

    tk.Label(app, text="Calculator Management System", font=("Arial", 16)).pack(pady=10)

    tk.Label(app, text="Select Calculator Number:").pack(pady=5)
    calculator_ids = [
        "A1", "A2", "A3", "A4", "A5", "A6",
        "B1", "B2", "B3", "B4", "B5", "B6",
        "C1", "C2", "C3", "C4", "C5", "C6",
        "D1", "D2", "D3", "D4", "D5", "D6"
    ]
    calculator_dropdown = ttk.Combobox(app, values=calculator_ids)
    calculator_dropdown.pack(pady=5)

    tk.Label(app, text="Student Name:").pack(pady=5)
    student_name_entry = tk.Entry(app)
    student_name_entry.pack(pady=5)

    tk.Button(app, text="Borrow Calculator", command=on_borrow, width=30).pack(pady=5)
    tk.Button(app, text="Return Calculator", command=on_return, width=30).pack(pady=5)
    tk.Button(app, text="View Calculator Inventory", command=view_inventory, width=30).pack(pady=5)
    tk.Button(app, text="Clear End of Day", command=clear_end_of_day, width=30).pack(pady=5)
    tk.Button(app, text="Exit", command=app.quit, width=30).pack(pady=20)

    app.mainloop()

# Run the app if the script is executed
if __name__ == "__main__":
    main_app()
